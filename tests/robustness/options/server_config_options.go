// Copyright 2023 The etcd Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by `make codegen`. DO NOT EDIT.

package options

import (
	e2e "go.etcd.io/etcd/tests/v3/framework/e2e"
	"time"
)

func (opts *ClusterOptions) WithSnapshotCount(input ...uint64) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.SnapshotCount = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithSnapshotCatchUpEntries(input ...uint64) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.SnapshotCatchUpEntries = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithMaxSnapFiles(input ...uint) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.MaxSnapFiles = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithMaxWalFiles(input ...uint) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.MaxWalFiles = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithTickMs(input ...uint) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.TickMs = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithElectionMs(input ...uint) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ElectionMs = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithInitialElectionTickAdvance(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.InitialElectionTickAdvance = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithBackendBatchInterval(input ...time.Duration) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.BackendBatchInterval = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithBackendBatchLimit(input ...int) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.BackendBatchLimit = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithQuotaBackendBytes(input ...int64) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.QuotaBackendBytes = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithMaxTxnOps(input ...uint) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.MaxTxnOps = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithMaxRequestBytes(input ...uint) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.MaxRequestBytes = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithMaxConcurrentStreams(input ...uint32) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.MaxConcurrentStreams = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithClientAutoTLS(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ClientAutoTLS = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithPeerAutoTLS(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.PeerAutoTLS = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithSelfSignedCertValidity(input ...uint) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.SelfSignedCertValidity = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithStrictReconfigCheck(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.StrictReconfigCheck = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithGRPCKeepAliveMinTime(input ...time.Duration) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.GRPCKeepAliveMinTime = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithGRPCKeepAliveInterval(input ...time.Duration) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.GRPCKeepAliveInterval = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithGRPCKeepAliveTimeout(input ...time.Duration) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.GRPCKeepAliveTimeout = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithPreVote(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.PreVote = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithBcryptCost(input ...uint) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.BcryptCost = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithAuthTokenTTL(input ...uint) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.AuthTokenTTL = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalInitialCorruptCheck(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalInitialCorruptCheck = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalCorruptCheckTime(input ...time.Duration) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalCorruptCheckTime = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalCompactHashCheckEnabled(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalCompactHashCheckEnabled = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalCompactHashCheckTime(input ...time.Duration) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalCompactHashCheckTime = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalEnableLeaseCheckpoint(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalEnableLeaseCheckpoint = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalEnableLeaseCheckpointPersist(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalEnableLeaseCheckpointPersist = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalCompactionBatchLimit(input ...int) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalCompactionBatchLimit = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalCompactionSleepInterval(input ...time.Duration) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalCompactionSleepInterval = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalWatchProgressNotifyInterval(input ...time.Duration) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalWatchProgressNotifyInterval = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalWarningApplyDuration(input ...time.Duration) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalWarningApplyDuration = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalBootstrapDefragThresholdMegabytes(input ...uint) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalBootstrapDefragThresholdMegabytes = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithWarningUnaryRequestDuration(input ...time.Duration) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.WarningUnaryRequestDuration = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalWarningUnaryRequestDuration(input ...time.Duration) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalWarningUnaryRequestDuration = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalMaxLearners(input ...int) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalMaxLearners = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithForceNewCluster(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ForceNewCluster = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithEnablePprof(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.EnablePprof = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalEnableDistributedTracing(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalEnableDistributedTracing = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalDistributedTracingSamplingRatePerMillion(input ...int) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalDistributedTracingSamplingRatePerMillion = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithEnableLogRotation(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.EnableLogRotation = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithEnableGRPCGateway(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.EnableGRPCGateway = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithUnsafeNoFsync(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.UnsafeNoFsync = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalDowngradeCheckTime(input ...time.Duration) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalDowngradeCheckTime = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalMemoryMlock(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalMemoryMlock = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalTxnModeWriteWithSharedBuffer(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalTxnModeWriteWithSharedBuffer = input[Rand.Intn(len(input))]
	})
	return opts
}
func (opts *ClusterOptions) WithExperimentalStopGRPCServiceOnDefrag(input ...bool) *ClusterOptions {
	*opts = append(*opts, func(c *e2e.EtcdProcessClusterConfig) {
		c.ServerConfig.ExperimentalStopGRPCServiceOnDefrag = input[Rand.Intn(len(input))]
	})
	return opts
}
