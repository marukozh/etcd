// Copyright 2023 The etcd Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bufio"
	"fmt"
	"os"
	"reflect"
	"strings"

	"github.com/dave/jennifer/jen"

	"go.etcd.io/etcd/server/v3/embed"
)

var licenseStr = `// Copyright 2023 The etcd Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
`

func main() {
	generateRobustnessServerConfigOptions()
}

func generateRobustnessServerConfigOptions() {
	f := jen.NewFile("options")
	cfg := *embed.NewConfig()
	t := reflect.TypeOf(cfg)
	n := t.NumField()
	for i := 0; i < n; i++ {
		elementT := t.Field(i)
		if !elementT.IsExported() {
			continue
		}
		switch elementT.Type.String() {
		case "bool":
		case "int", "int32", "int64":
		case "uint", "uint32", "uint64":
		case "time.Duration":
		default:
			continue
		}
		addRandomizableWithFunc(f, elementT.Name, elementT.Type.String())
	}

	fout, err := os.Create("tests/robustness/options/server_config_options.go")
	if err != nil {
		fmt.Println("File does not exists or cannot be created")
		os.Exit(1)
	}
	defer fout.Close()

	w := bufio.NewWriter(fout)
	fmt.Fprintf(w, "%s\n", licenseStr)
	fmt.Fprintf(w, "%s\n\n", "// Code generated by `make codegen`. DO NOT EDIT.")
	fmt.Fprintf(w, "%#v", f)
	w.Flush()
}

func addRandomizableWithFunc(f *jen.File, fieldName, fieldType string) {
	part := f.Func().Params(jen.Id("opts").Op("*").Id("ClusterOptions")).Id("With" + fieldName)

	if strings.Contains(fieldType, ".") {
		idx := strings.LastIndex(fieldType, ".")
		part.Params(jen.Id("input").Id("...").Qual(fieldType[:idx], fieldType[idx+1:]))
	} else {
		part.Params(jen.Id("input").Id("...").Id(fieldType))
	}

	funcEPClusterOption := jen.Func().Params(jen.Id("c").Op("*").Qual("go.etcd.io/etcd/tests/v3/framework/e2e", "EtcdProcessClusterConfig")).Block(jen.Id("c").Dot("ServerConfig").Dot(fieldName).Op("=").Id("input").Index(jen.Id("Rand").Dot("Intn").Call(jen.Id("len").Call(jen.Id("input")))))
	part.Id("*ClusterOptions").Block(
		jen.Id("*opts").Op("=").Id("append").Call(jen.Id("*opts"), funcEPClusterOption),
		jen.Return(jen.Id("opts")),
	)
}
